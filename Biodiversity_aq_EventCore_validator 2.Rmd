---
title: "Data validation protocol for DarwinCore Event Core"
author: "Maxime Sweetlove"
output: pdf_document
---

`r Sys.Date()`

### 0.1. Summary
This is the standardized protocol to validate wether biodiversity data conforms to DarwinCore before publishing to ipt.biodiversity.aq. This protocol assums the data has already been qualty controlled and standardized into DarwinCore Event Core CSV file (with columns as DarwinCore terms and rows as occurrences).

The protocol is fully automated, following the phylosophy that computers need to be able to parse and understand the data to be able to querry and subset it for human use. Any potential issues are flagged in the PDF report that is generated by running knitr.

### 0.2. How to use this protocol
Step 0: make sure R markdown and Knitr work*. 
Step 1: install all required libraries and check if they work (see code section 0.3).**
Step 2: change the working directory and file name to the dataset that needs to be checked (see code section 0.4)
Step 3: Knit the document, a PDF report of the QC will be generated.
Notice: Fixing issues goes beyond the scope of this protocol and need to be adressed by the user.

*If you can't get R markdown and Knitr to work, code blocks can also be copy-pasted into an R script and run like that.
**If you have trouble installing the MicrobeDataTools package, alternatively the TermsLib table can be downloaded and used locally.

Before you start, please change the directory paths and file names below, as specified by the comment.
```{r user_setting, echo = FALSE}
# 0.0. User settings
##########################################
# START CHANGING CODE HERE
#  in datasetDir, place path to the directory where the files live (required parameter)
datasetDir <- "/Users/msweetlove/Desktop/Belgica121/03_processed"
#to list the files in the directory
#list.files(datasetDir)
# in fileName_eventCore, place the name of the event core file (CSV) (required parameter)
fileName_eventCore <- "B121_eventCore_workingversion.csv"
# in fileName_occurExt, place the name of the occurrence extension file (CSV), leave blank ("") if there is none
fileName_occurExt <- "B121_occurrenceExtension.csv"
# STOP CHANGING CODE HERE
##########################################
```

```{r setting_up, echo=FALSE, message=FALSE}
knitr::opts_chunk$set(tidy = TRUE, tidy.opts = list(comment = FALSE), echo=FALSE) #global options for knittr
# 0.3. Setting up the environment
defaultW <- getOption("warn") # to supress warnings when loading a package
options(warn = -1) 
library(obistools)
library(MicrobeDataTools)

options(warn = defaultW)

# read the library of DarwinCore terms
dwc_lib <- MicrobeDataTools::TermsLib

# to collect all the issues
QC_report <- data.frame(section=character(), #the type of QC that was done
                        level=character(), #either recommendation, warning, error or fatal error
                        field=character(), # the column name causing an issue
                        row=character(),  # the now number where the issue occured
                        value=character(), # the value of the field that causes the issue
                        message=character()) #the message explaining the issue

```


```{r read_data, echo = FALSE}
# 0.4. Reading the data.
eventCore<- read.csv(paste(datasetDir, fileName_eventCore, sep="/"))
if(!is.na(fileName_occurExt) | fileName_occurExt!=""){
  has_occurExt <- TRUE
  occurExt<- read.csv(paste(datasetDir, fileName_occurExt, sep="/"))
} else{
  has_occurExt <- FALSE
}
```


# Quality Control report for the dataset `r fileName_eventCore` .

## Part 1. QC on DarwinCore
This part of the QC focuses on the format of the data as a DarwinCore Event Core file. 
The table below displays the issues that were discovered.
```{r QC_DwC, echo = FALSE}
# 1.1. are all column names DarwinCore terms?
condition <- setdiff(colnames(eventCore), dwc_lib[dwc_lib$DwC_Event>0,]$name)
if(has_occurExt){
  condition <- c(condition, setdiff(colnames(occurExt), dwc_lib[dwc_lib$DwC_Occurrence>0,]$name))
}
if(length(condition)>0){
  for(cd in 1:length(condition)){
    QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="fatal_error",
                                  field=condition[cd],
                                  row=NA,
                                  value=NA,
                                  message="not a DarwinCore term"))
  }
}

# 1.2. are all the mandatory columns (=fields) present?
required_event <- c("eventDate", "decimalLongitude", "decimalLatitude", "eventID")
# based on required by OBIS: 
required_occur <- c("occurrenceID", "eventDate", "decimalLongitude", "decimalLatitude",  "eventID",
              "scientificName", "scientificNameID", "occurrenceStatus", "basisOfRecord")

#eventCore
condition <- length(intersect(colnames(eventCore), required_event)) == length(required_event)
if(!condition){
  missing <- setdiff(required, colnames(eventCore))
    for(ms in missing){
    QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="fatal_error",
                                  field=ms,
                                  row=NA,
                                  value=NA,
                                  message="eventCore: Required term missing"))
  }
}
#occurrence extension
if(has_occurExt){
  condition <- length(intersect(colnames(occurExt), required_occur)) == length(required_occur)
  if(!condition){
    missing <- setdiff(required, colnames(occurExt))
      for(ms in missing){
      QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="fatal_error",
                                  field=ms,
                                  row=NA,
                                  value=NA,
                                  message="occurExt: Required term missing"))
    }
  }
}

# 1.3. any missing values in the required fields?
#event Core
for(field in required_event){
  if(field %in% colnames(eventCore)){
    condition <- which(eventCore[,field] %in% c(NA, ""))
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="warning",
                                  field=field,
                                  row=condition[cd],
                                  value=NA,
                                  message="eventCore: missing value for required term"))
      }
    }
  }
}
#occurrence extension
if(has_occurExt){
  for(field in required_occur){
  if(field %in% colnames(occurExt)){
    condition <- which(occurExt[,field] %in% c(NA, ""))
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="warning",
                                  field=field,
                                  row=condition[cd],
                                  value=NA,
                                  message="occurExt: missing value for required term"))
      }
    }
  }
}
}

# 1.4. are there empty columns or rows?
condition <- which(colSums(is.na(eventCore)) >= (nrow(eventCore)))
if(length(condition)>0){
  for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="warning",
                                  field=colnames(eventCore)[condition[cd]],
                                  row=NA,
                                  value=NA,
                                  message="eventCore: This column is empty"))
  }
}
if(has_occurExt){
  condition <- c(condition, which(colSums(is.na(occurExt)) >= (nrow(occurExt))))
  if(length(condition)>0){
    for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                        data.frame(section="QC_DwC",
                                  level="warning",
                                  field=colnames(occurExt)[condition[cd]],
                                  row=NA,
                                  value=NA,
                                  message="occurExt: This column is empty"))
    }
  }
}

condition <- which(rowSums(is.na(eventCore)) >= (ncol(eventCore)))
if(length(condition)>0){
  for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="warning",
                                  field=NA,
                                  row=condition[cd],
                                  value=NA,
                                  message="eventCore: This row is empty"))
  }
}
if(has_occurExt){
  condition <- c(condition, which(rowSums(is.na(occurExt)) >= (ncol(occurExt))))
  if(length(condition)>0){
    for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="warning",
                                  field=NA,
                                  row=condition[cd],
                                  value=NA,
                                  message="occurExt: This row is empty"))
    }
  }
}


# 1.5. is basisOfRecord correctly formatted?
if(has_occurExt){
  if("basisOfRecord" %in% colnames(occurExt)){
  condition <- occurExt$basisOfRecord %in% c("HumanObservation", "PreservedSpecimen", "FossilSpecimen", "LivingSpecimen", "MaterialSample", "Event", "MachineObservation", "Taxon", "Occurrence")
  if(any(!condition)){
    cond2 <- which(!occurExt$basisOfRecord %in% c("HumanObservation", "PreservedSpecimen", "FossilSpecimen", "LivingSpecimen", "MaterialSample", "Event", "MachineObservation", "Taxon", "Occurrence"))
      for(cd in 1:length(cond2)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="fatal_error",
                                  field="basisOfRecord",
                                  row=cond2[cd],
                                  value=occurExt$basisOfRecord[cond2[cd]],
                                  message="Incorrect value for basisOfRecord"))
    }
  }
}
}

# 1.6. are recommended terms missing from the eventCore?
recommended <- c("coordinateUncertaintyInMeters", "samplingProtocol", "locality", "rights", "license", "modified", "year", "month", "day", "datasetID")
condition1 <- length(intersect(colnames(eventCore), recommended)) == length(recommended)
if(!condition){
  missing_ev <- setdiff(recommended, colnames(eventCore))
    for(ms in missing){
    QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="warning",
                                  field=ms,
                                  row=NA,
                                  value=NA,
                                  message="eventCore: Recommended term missing"))
  }
}

# 1.7. return output
if(nrow(QC_report[QC_report$section=="QC_DwC",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_DwC",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}
```


## Part 2. QC on correct use of identifiers
The content of different ID fields (e.g. occurrenceID) is evaluated. Issues may include duplicated values or erroneous references of IDs between tables. The table below displays the issues that were discovered.
``` {r QC_IDs, echo = FALSE}
# 2.1. are all IDs unique?
# 2.1.1 eventID
if("eventID" %in% colnames(eventCore)){
  condition <- duplicated(eventCore$eventID)
  if(any(condition)){
    cond2 <- which(duplicated(eventCore$eventID))
      for(cd in 1:length(cond2)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_IDs",
                                  level="fatal_error",
                                  field="eventID",
                                  row=cond2[cd],
                                  value=condition[cd],
                                  message="eventID is duplicated"))
    }
  }
}
# 2.1.2 occurrenceIDs
if(has_occurExt){
  if("occurrenceID" %in% colnames(occurExt)){
  condition <- duplicated(occurExt$occurrenceID)
    if(any(condition)){
      cond2 <- which(duplicated(occurExt$occurrenceID))
        for(cd in 1:length(cond2)){
          QC_report <- rbind(QC_report, 
                         data.frame(section="QC_IDs",
                                    level="fatal_error",
                                    field="occurrenceID",
                                    row=cond2[cd],
                                    value=condition[cd],
                                    message="occurrenceID is duplicated"))
      }
    }
  }
}


# 2.2. no spaces, hyphens, ... in IDs
# 2.2.1 eventID
if("eventID" %in% colnames(eventCore)){
  condition <- which(!grepl("^([[:alnum:]]|:|_)*$", eventCore$eventID))
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                         data.frame(section="QC_IDs",
                                    level="error",
                                    field="eventID",
                                    row=condition[cd],
                                    value= eventCore$eventID[condition[cd]],
                                    message="illigal character"))
    }
  }
}
# 2.2.2 occurrenceID
if(has_occurExt){
  if("occurrenceID" %in% colnames(occurExt)){
    condition <- which(!grepl("^([[:alnum:]]|:|_)*$", occurExt$occurrenceID))
     if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                           data.frame(section="QC_IDs",
                                      level="error",
                                      field="occurrenceID",
                                      row=condition[cd],
                                      value= occurExt$occurrenceID[condition[cd]],
                                      message="illigal character"))
      }
    }
  }
}

# 2.3. What eventIDs are not diffrent from their parentEventID?
if("eventID" %in% colnames(eventCore) & "parentEventID" %in% colnames(eventCore)){
  condition <- which(eventCore$eventID == eventCore$parentEventID)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                         data.frame(section="QC_IDs",
                                    level="error",
                                    field="eventID",
                                    row=condition[cd],
                                    value= eventCore$eventID[condition[cd]],
                                    message="eventCore: eventID equals parentEventID"))
    }
  }
}

# 2.4. Do all parentEventIDs have corresponding eventID?
if("eventID" %in% colnames(eventCore) & "parentEventID" %in% colnames(eventCore)){
  condition <- which(!(setdiff(eventCore$parentEventID, c(NA, "NA", "")) %in% eventCore$eventID))
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                         data.frame(section="QC_IDs",
                                    level="error",
                                    field="eventID",
                                    row=condition[cd],
                                    value= eventCore$parentEventID[condition[cd]],
                                    message="eventCore: parentEventID not among the eventIDs"))
    }
  }
}

# 2.5 do all occurrenceIDs have an eventID?
if(has_occurExt){
  if("eventID" %in% colnames(occurExt) & "occurrenceID" %in% colnames(occurExt)){
    condition <- which(occurExt$eventID %in% c(NA, ""))
      if(length(condition)>0){
        for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                           data.frame(section="QC_IDs",
                                      level="error",
                                      field="eventID",
                                      row=condition[cd],
                                      value= occurExt$occurrenceID[condition[cd]],
                                      message="occurExt: occurrence not linked to an event"))
      }
    }
  }
}

# 2.6. are all eventIDs of the occurrence extension in the eventCore?
if(has_occurExt){
  if("eventID" %in% colnames(occurExt) & "eventID" %in% colnames(eventCore)){
    condition <- which(!occurExt$eventID %in% eventCore$eventID)
      if(length(condition)>0){
        for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                           data.frame(section="QC_IDs",
                                      level="error",
                                      field="eventID",
                                      row=condition[cd],
                                      value= occurExt$eventID[condition[cd]],
                                      message="occurExt: eventID not in the eventCore"))
      }
    }
  }
}

# 2.7 return output
if(nrow(QC_report[QC_report$section=="QC_IDs",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_IDs",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}

```


## Part 3. QC on taxonomy
The taxonomic information in the dataset is checked for correct formatting of the scientific name, and for linkage to the WoRMS taxonomic backbone (scientificNameID, formatted as urn:lsid). The table below displays the issues that were discovered.
``` {r QC_taxonomy, echo = FALSE}
if(has_occurExt){
  # 3.1. are all scientific names correctly formatted?
  not_allowed <- "sp.$|sp$|spp.$|spp$|[0-9]|(gen(.) nov)|(gen nov)|(gen(.)nov)|^ | $|cf|var$|var.$|^[a-z]|[[:punct:]]"
  if("scientificName" %in% colnames(occurExt)){
    missing_val <- occurExt$scientificName %in% c(NA, "") 
    bad_format <- grepl(not_allowed, occurExt$scientificName)
    condition <- which(bad_format & !missing_val)
    if(length(condition)>0){
        for(cd in 1:length(condition)){
            QC_report <- rbind(QC_report, 
                      data.frame(section="QC_taxonomy",
                                level="error",
                                field="scientificName",
                                row=condition[cd],
                                value=occurExt$scientificName[condition[cd]],
                                message="incorrect format"))
    }
  }
}

  # 3.2. are taxonIDs correctly formatted?
  if("scientificNameID" %in% colnames(occurExt)){
    missing_val <- occurExt$scientificNameID %in% c(NA, "") #the empty fields, was checked before
    missing_num <- !grepl("[0-9]", occurExt$scientificNameID) #must contain numerics
    missing_format <- !grepl("urn:lsid:", occurExt$scientificNameID, fixed=T)# must start with urn:lsid:
  
    condition <- which((missing_num | missing_format) & !missing_val)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                           data.frame(section="QC_taxonomy",
                                      level="warning",
                                      field="scientificNameID",
                                      row=condition[cd],
                                      value= occurExt$scientificName[condition[cd]],
                                      message="incorrect format"))
      }
    }
  }

  # 3.2 return output
  if(nrow(QC_report[QC_report$section=="QC_taxonomy",])>0){
    knitr::kable(QC_report[QC_report$section=="QC_taxonomy",colnames(QC_report) %in% c("field","row", "value", "message")])
  } else{message("-- no issues found --")}
}else{
  message("-- no issues found --")
  }

```

## Part 4. QC on geography
The geographic locations of the occurrences are inspected. A common error is inflated precision (number of decimal places) of the coordinates as a result of converting from degrees-minutes-seconds to decimal degrees. Coordinates need to be rounded to the same percision as te original sample. Increasing the number of decimal places suggests the position of the occurence was more precisely measured than it actually was.

The map below allows for a visual inspection.
``` {r QC_geo_plot, echo = FALSE}
# 4.1. plot points on a map
obistools::plot_map(eventCore)
```

The table below displays the issues that were discovered.
``` {r QC_geo, echo = FALSE}
# 4.2. are coordinates too precise? more than 6 decimals may point to this
geofields<- c("decimalLatitude", "decimalLongitude")
for(geofield in geofields){
  if(geofield %in% colnames(eventCore)){
    coords_dec <- unname(sapply(eventCore[,geofield], function(x){str_split(as.character(x), "\\.")[[1]][2]}))
    coords_dec[is.na(coords_dec)] <- 0
    condition <- which(nchar(coords_dec)>6)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                         data.frame(section="QC_geo",
                                    level="warning",
                                    field=geofield,
                                    row=condition[cd],
                                    value=eventCore$decimalLatitude[condition[cd]],
                                    message="eventCore: precision may be inflated"))
      }
    }
  }
  if(has_occurExt){
    if(geofield %in% colnames(occurExt)){
      coords_dec <- unname(sapply(occurExt[,geofield], function(x){str_split(as.character(x), "\\.")[[1]][2]}))
      coords_dec[is.na(coords_dec)] <- 0
      condition <- which(nchar(coords_dec)>6)
      if(length(condition)>0){
        for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                           data.frame(section="QC_geo",
                                      level="warning",
                                      field=geofield,
                                      row=condition[cd],
                                      value=occurExt$decimalLatitude[condition[cd]],
                                      message="occurExt: precision may be inflated"))
        }
      }
    }
  }
}

# 4.3. do coordinates in the eventCore and occurrence extension match?
# ToDo

# 4.4 return output
if(nrow(QC_report[QC_report$section=="QC_geo",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_geo",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}

```


## Part 5. date and time
Date and time values need to be formatted as followed: YYYY-MM-DD, YYYY-MM-DDThh:mm, YYYY-MM-DDThh:mmZ. Any deviation of this format will be flaged. In addition, the dates intselves are checked for obvious typos, such as years <1500 or >present, months that exceed 12 or days that exceed 31. The table below displays the issues that were discovered.
``` {r QC_date, echo = FALSE}
# 5.1. are dates formatted correctly?
# correct format YYYY-MM-DD, YYYY-MM-DDThh:mm, YYYY-MM-DDThh:mmZ
datefields <- c("eventDate", "modified", "dateIdentified")
date_pattern <- "^\\d{4}(-\\d{2}(-\\d{2}([T|\\s]\\d{2}(:\\d{2}(:\\d{2})?)?(Z|([+-]\\d{2}:?(\\d{2})?))?)?)?)?$"
for(datefield in datefields){
  # eventCore
  if(datefield %in% colnames(eventCore)){
    wrong_date <- !grepl(date_pattern, eventCore[,datefield])
    no_date <- eventCore[,datefield] %in% c(NA, "")
    condition <- which(wrong_date & !no_date)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
           QC_report <- rbind(QC_report, 
                       data.frame(section="QC_date",
                                  level="error",
                                  field=datefield,
                                  row=condition[cd],
                                  value=eventCore[condition[cd], datefield],
                                  message="eventCore: invalid date format"))

      }
    }
        
    year <- unname(sapply(eventCore[,datefield], function(x){str_split(x, "-")[[1]][1]}))
    bad_year <- (year<1500 | year>as.numeric(str_split(Sys.Date(), "-")[[1]][1]))
    bad_year[is.na(bad_year)] <- FALSE
    condition <- which(bad_year & !wrong_date & !no_date)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                       data.frame(section="QC_date",
                                  level="warning",
                                  field=datefield,
                                  row=condition[cd],
                                  value=eventCore[condition[cd], datefield],
                                  message="eventCore: invalid year (<1500 or >present)"))
      }
    }
    month <- unname(sapply(eventCore[,datefield], function(x){str_split(x, "-")[[1]][2]}))
    bad_month <- (month<0 | month>12)
    bad_month[is.na(bad_month)] <- FALSE
    condition <- which(bad_month & !bad_year & !wrong_date & !no_date)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                       data.frame(section="QC_date",
                                  level="warning",
                                  field=datefield,
                                  row=condition[cd],
                                  value=eventCore[condition[cd], datefield],
                                  message="eventCore: invalid month (<0 or >12)"))

      }
    }
    day <- unname(sapply(eventCore[,datefield], function(x){str_split(x, "-")[[1]][3]}))
    bad_day <- (day<0 | day>31)
    bad_day[is.na(bad_day)] <- FALSE
    condition <- which(bad_day & !bad_month & !bad_year & !wrong_date & !no_date)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                       data.frame(section="QC_date",
                                  level="warning",
                                  field=datefield,
                                  row=condition[cd],
                                  value=eventCore[condition[cd], datefield],
                                  message="eventCore: invalid day (<0 or >31)"))
      }
    }
  }
  
  # occurrence extension
  if(has_occurExt & datefield %in% colnames(occurExt)){
    wrong_date <- !grepl(date_pattern, occurExt[,datefield])
    no_date <- occurExt[,datefield] %in% c(NA, "")
    condition <- which(wrong_date & !no_date)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
           QC_report <- rbind(QC_report, 
                       data.frame(section="QC_date",
                                  level="error",
                                  field=datefield,
                                  row=condition[cd],
                                  value=eventCore[condition[cd], datefield],
                                  message="occurExt: invalid date format"))

      }
    }
        
    year <- unname(sapply(occurExt[,datefield], function(x){str_split(x, "-")[[1]][1]}))
    bad_year <- (year<1500 | year>as.numeric(str_split(Sys.Date(), "-")[[1]][1]))
    bad_year[is.na(bad_year)] <- FALSE
    condition <- which(bad_year & !wrong_date & !no_date)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                       data.frame(section="QC_date",
                                  level="warning",
                                  field=datefield,
                                  row=condition[cd],
                                  value=occurExt[condition[cd], datefield],
                                  message="occurExt: invalid year (<1500 or >present)"))
      }
    }
    month <- unname(sapply(occurExt[,datefield], function(x){str_split(x, "-")[[1]][2]}))
    bad_month <- (month<0 | month>12)
    bad_month[is.na(bad_month)] <- FALSE
    condition <- which(bad_month & !bad_year & !wrong_date & !no_date)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                       data.frame(section="QC_date",
                                  level="warning",
                                  field=datefield,
                                  row=condition[cd],
                                  value=occurExt[condition[cd], datefield],
                                  message="occurExt: invalid month (<0 or >12)"))

      }
    }
    day <- unname(sapply(occurExt[,datefield], function(x){str_split(x, "-")[[1]][3]}))
    bad_day <- (day<0 | day>31)
    bad_day[is.na(bad_day)] <- FALSE
    condition <- which(bad_day & !bad_month & !bad_year & !wrong_date & !no_date)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                       data.frame(section="QC_date",
                                  level="warning",
                                  field=datefield,
                                  row=condition[cd],
                                  value=occurExt[condition[cd], datefield],
                                  message="occurExt: invalid day (<0 or >31)"))
      }
    }
  }
}

# 5.2. are years formatted correctly?
# eventCore
if("year" %in% colnames(eventCore)){
    empty_val <- eventCore$year %in% c(NA, "")
    bad_format <- !grepl("^[1-2][0-9]{3}$|^[1-2][0-9]{3}/[1-2][0-9]{3}$",eventCore$year)
    condition <- which(bad_format & !empty_val)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_date",
                                     level="warning",
                                     field="year",
                                     row=condition[cd],
                                     value=eventCore$year[condition[cd]],
                                     message="eventCore: incorrect format or value"))
      }
    }
    # for ranges YYYY/YYYY: check if year1 < year2
    date_ranges <- grep("^[1-2][0-9]{3}/[1-2][0-9]{3}$",eventCore$year)
    for(date_row in date_ranges){
      date_x <- str_split(as.character(eventCore$year[date_row]), "/")[[1]]
      if(date_x[1]>=date_x[2]){
        QC_report <- rbind(QC_report, 
                         data.frame(section="QC_date",
                                     level="warning",
                                     field="year",
                                     row=date_row,
                                     value=eventCore$year[date_row],
                                     message="eventCore: year1 >= year2"))
    }
  }
}
# occurence extension
if(has_occurExt & "year" %in% colnames(occurExt)){
    empty_val <- occurExt$year %in% c(NA, "")
    bad_format <- !grepl("^[1-2][0-9]{3}$|^[1-2][0-9]{3}/[1-2][0-9]{3}$",occurExt$year)
    condition <- which(bad_format & !empty_val)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_date",
                                     level="warning",
                                     field="year",
                                     row=condition[cd],
                                     value=occurExt$year[condition[cd]],
                                     message="occurExt: incorrect format or value"))
      }
    }
    # for ranges YYYY/YYYY: check if year1 < year2
    date_ranges <- grep("^[1-2][0-9]{3}/[1-2][0-9]{3}$",occurExt$year)
    for(date_row in date_ranges){
      date_x <- str_split(as.character(occurExt$year[date_row]), "/")[[1]]
      if(date_x[1]>=date_x[2]){
        QC_report <- rbind(QC_report, 
                         data.frame(section="QC_date",
                                     level="warning",
                                     field="year",
                                     row=date_row,
                                     value=occurExt$year[date_row],
                                     message="occurExt: year1 >= year2"))
    }
  }
}

# 5.3. are months formatted correctly?
#eventCore
if("month" %in% colnames(eventCore)){
    empty_val <- eventCore$month %in% c(NA, "")
    pattern_single <- "^[0-9]$|^[0][0-9]$|^[1][0-2]$"
    pattern_range1 <- "^(([0-9])|([1][0-2]))/(([0-9])|([1][0-2]))$"
    pattern_range2 <- "^(([0][0-9])|([1][0-2]))/(([0][0-9])|([1][0-2]))$"
    bad_format <- !grepl(paste(pattern_single, pattern_range1, pattern_range2, sep="|"),
                         eventCore$month)
    condition <- which(bad_format & !empty_val)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_date",
                                     level="warning",
                                     field="month",
                                     row=condition[cd],
                                     value=eventCore$month[condition[cd]],
                                     message="eventCore: incorrect format or value"))
      }
    }
}
#occurrence extension
if(has_occurExt & "month" %in% colnames(occurExt)){
    empty_val <- occurExt$month %in% c(NA, "")
    pattern_single <- "^[0-9]$|^[0][0-9]$|^[1][0-2]$"
    pattern_range1 <- "^(([0-9])|([1][0-2]))/(([0-9])|([1][0-2]))$"
    pattern_range2 <- "^(([0][0-9])|([1][0-2]))/(([0][0-9])|([1][0-2]))$"
    bad_format <- !grepl(paste(pattern_single, pattern_range1, pattern_range2, sep="|"),
                         occurExt$month)
    condition <- which(bad_format & !empty_val)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_date",
                                     level="warning",
                                     field="month",
                                     row=condition[cd],
                                     value=occurExt$month[condition[cd]],
                                     message="occurExt: incorrect format or value"))
      }
    }
}

# 5.4. are days formatted correctly?
# eventCore
if("day" %in% colnames(eventCore)){
    empty_val <- eventCore$day %in% c(NA, "")
    pattern_single <- "^[0-9]$|[0-2][0-9]$|^[3][0-1]$"
    pattern_range1 <- "^([0-9]|([1-2][0-9])|([3][0-1]))/([0-9]|([1-2][0-9])|([3][0-1]))$"
    pattern_range2 <- "^(([0-2][0-9])|([3][0-1]))/(([0-2][0-9])|([3][0-1]))$"
    bad_format <- !grepl(paste(pattern_single, pattern_range1, pattern_range2, sep="|"),
                         eventCore$day)
    condition <- which(bad_format & !empty_val)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_date",
                                     level="warning",
                                     field="day",
                                     row=condition[cd],
                                     value=eventCore$day[condition[cd]],
                                     message="eventCore: incorrect format or value"))
      }
    }
}
# occurrence extension
if(has_occurExt & "day" %in% colnames(occurExt)){
    empty_val <- occurExt$day %in% c(NA, "")
    pattern_single <- "^[0-9]$|[0-2][0-9]$|^[3][0-1]$"
    pattern_range1 <- "^([0-9]|([1-2][0-9])|([3][0-1]))/([0-9]|([1-2][0-9])|([3][0-1]))$"
    pattern_range2 <- "^(([0-2][0-9])|([3][0-1]))/(([0-2][0-9])|([3][0-1]))$"
    bad_format <- !grepl(paste(pattern_single, pattern_range1, pattern_range2, sep="|"),
                         occurExt$day)
    condition <- which(bad_format & !empty_val)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_date",
                                     level="warning",
                                     field="day",
                                     row=condition[cd],
                                     value=occurExt$day[condition[cd]],
                                     message="occurExt: incorrect format or value"))
      }
    }
}


# 5.5. return output
if(nrow(QC_report[QC_report$section=="QC_date",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_date",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}

```


## Part 6. QC on the content of some other fields.
Some fields, such as dynamicProperties, footprintWKT or numeric fields require a specificly formatted content. This is checked in this section. The table below displays the issues that were discovered.
``` {r QC_miscellaneous, echo = FALSE}
# 6.1. is dynamicProperties formatted correctly?
# correct format: {field1:value1}, {field2:value2}
# eventCore
if("dynamicProperties" %in% colnames(eventCore)){
  empty_val <- eventCore$dynamicProperties %in% c(NA, "")
  bad_format <-   !grepl("^\\{.*\\:.*\\}$", eventCore$dynamicProperties) & #start with {, end with }
                      grepl("( \\})", eventCore$dynamicProperties) & #no trailing space
                      grepl("(\\: )", eventCore$dynamicProperties) & #no trailing space
                      grepl("( \\:)", eventCore$dynamicProperties) #no leading space

  condition <- which(bad_format & !empty_val)
  if(length(condition)>0){
    for(cd in 1:length(condition)){
      QC_report <- rbind(QC_report, 
                         data.frame(section="QC_miscellaneous",
                                    level="error",
                                    field="dynamicProperties",
                                    row=condition[cd],
                                    value=eventCore$dynamicProperties[condition[cd]],
                                    message="eventCore: incorrect format for dynamicProperties"))
    }
  }
}
# occurrence extension
if(has_occurExt & "dynamicProperties" %in% colnames(occurExt)){
  empty_val <- occurExt$dynamicProperties %in% c(NA, "")
  bad_format <-   !grepl("^\\{.*\\:.*\\}$", occurExt$dynamicProperties) & #start with {, end with }
                      grepl("( \\})", occurExt$dynamicProperties) & #no trailing space
                      grepl("(\\: )", occurExt$dynamicProperties) & #no trailing space
                      grepl("( \\:)", occurExt$dynamicProperties) #no leading space

  condition <- which(bad_format & !empty_val)
  if(length(condition)>0){
    for(cd in 1:length(condition)){
      QC_report <- rbind(QC_report, 
                         data.frame(section="QC_miscellaneous",
                                    level="error",
                                    field="dynamicProperties",
                                    row=condition[cd],
                                    value=occurExt$dynamicProperties[condition[cd]],
                                    message="occurExt: incorrect format for dynamicProperties"))
    }
  }
}

# 6.2. is footprintWKT formatted correctly? Is the precision believabe?
# correct format: POINT (p1, p2), LINESTRING, POLYGON, MULTiPOINT, MULTILINESTRING, MULTIPOLYGON
# eventCore
if("footprintWKT" %in% colnames(eventCore)){
  empty_val <- eventCore$footprintWKT %in% c(NA, "")
  bad_format <- !grepl("POINT|LINESTRING|POLYGON|MULTiPOINT|MULTILINESTRING|MULTIPOLYGON", eventCore$footprintWKT)

  coords_dec <- unname(sapply(eventCore$footprintWKT, function(x){str_split(as.character(x), "\\.")[[1]][2]})) 
  coords_dec <- unname(sapply(coords_dec, function(x){str_split(as.character(x), " ")[[1]][1]})) 
  coords_dec[is.na(coords_dec)] <- 0
  too_precise <- which(nchar(coords_dec)>6)

  condition <- which(bad_format | too_precise & !empty_val)
  if(length(condition)>0){
    for(cd in 1:length(condition)){
      QC_report <- rbind(QC_report, 
                        data.frame(section="QC_miscellaneous",
                                   level="warning",
                                   field="footprintWKT",
                                   row=condition[cd],
                                   value=eventCore$footprintWKT[condition[cd]],
                                   message="eventCore: incorrect format for WKT"))
    }
  }
}
# occurrence extension
if(has_occurExt & "footprintWKT" %in% colnames(occurExt)){
  empty_val <- occurExt$footprintWKT %in% c(NA, "")
  bad_format <- !grepl("POINT|LINESTRING|POLYGON|MULTiPOINT|MULTILINESTRING|MULTIPOLYGON", occurExt$footprintWKT)

  coords_dec <- unname(sapply(occurExt$footprintWKT, function(x){str_split(as.character(x), "\\.")[[1]][2]})) 
  coords_dec <- unname(sapply(coords_dec, function(x){str_split(as.character(x), " ")[[1]][1]})) 
  coords_dec[is.na(coords_dec)] <- 0
  too_precise <- which(nchar(coords_dec)>6)

  condition <- which(bad_format | too_precise & !empty_val)
  if(length(condition)>0){
    for(cd in 1:length(condition)){
      QC_report <- rbind(QC_report, 
                        data.frame(section="QC_miscellaneous",
                                   level="warning",
                                   field="footprintWKT",
                                   row=condition[cd],
                                   value=occurExt$footprintWKT[condition[cd]],
                                   message="occurExt: incorrect format for WKT"))
    }
  }
}

# 6.3. is occurrenceStatus formatted correctly?
# correct format: present, absent
if(has_occurExt & "occurrenceStatus" %in% colnames(occurExt)){
  empty_val <- occurExt$occurrenceStatus %in% c(NA, "")
  bad_format <- !grepl("^present$|^absent$", occurExt$occurrenceStatus)
  condition <- which(bad_format & !empty_val)
  if(length(condition)>0){
    for(cd in 1:length(condition)){
      QC_report <- rbind(QC_report, 
                        data.frame(section="QC_miscellaneous",
                                   level="error",
                                   field="occurrenceStatus",
                                   row=condition[cd],
                                   value=occurExt$occurrenceStatus[condition[cd]],
                                   message="occurExt: incorrect value for occurrenceStatus"))
    }
  }
}

# 6.4. are there non-numeric values in numeric fields?
num_fields <- c("decimalLatitude", "decimalLongitude", "minimumDepthInMeters", "maximumDepthInMeters", 
               "organismQuantity",  "individualCount", "maximumElevationInMeters",
               "minimumElevationInMeters", "coordinateUncertaintyInMeters", "namePublishedInYear",
               "minimumDistanceAboveSurfaceInMeters", "maximumDistanceAboveSurfaceInMeters")
for(num_field in num_fields){
  # eventCore
  if(num_field %in% colnames(eventCore)){
    empty_val <- eventCore[,num_field] %in% c(NA, "")
    bad_format <- grepl("[[:alpha:]]|[[:space:]]", eventCore[,num_field])
    condition <- which(bad_format & !empty_val)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_miscellaneous",
                                     level="error",
                                     field=num_field,
                                     row=condition[cd],
                                     value=eventCore[,num_field][condition[cd]],
                                     message="eventCore: non numeric value"))
      }
    }
  }
  # occurrence extension
  if(has_occurExt & num_field %in% colnames(occurExt)){
    empty_val <- occurExt[,num_field] %in% c(NA, "")
    bad_format <- grepl("[[:alpha:]]|[[:space:]]", occurExt[,num_field])
    condition <- which(bad_format & !empty_val)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_miscellaneous",
                                     level="error",
                                     field=num_field,
                                     row=condition[cd],
                                     value=occurExt[,num_field][condition[cd]],
                                     message="occurExt: non numeric value"))
      }
    }
  }
}

# 6.5 are there negative values in fields that can only be positive?
pos_fields <- c("minimumDepthInMeters", "maximumDepthInMeters", 
               "organismQuantity", "individualCount", "maximumElevationInMeters",
               "minimumElevationInMeters", "coordinateUncertaintyInMeters", "namePublishedInYear", 
               "minimumDistanceAboveSurfaceInMeters", "maximumDistanceAboveSurfaceInMeters")
for(pos_field in pos_fields){
  # eventCore
  if(pos_field %in% colnames(eventCore)){
    empty_val <- eventCore[,pos_field] %in% c(NA, "")
    no_num <- grepl("[[:alpha:]]|[[:space:]]", eventCore[,pos_field])
    bad_format <- grepl("^-", eventCore[,pos_field])
    
    condition <- which(bad_format & !empty_val & !no_num)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_miscellaneous",
                                     level="error",
                                     field=pos_field,
                                     row=condition[cd],
                                     value=eventCore[,pos_field][condition[cd]],
                                     message="no negative values allowed"))
      }
    }
  }
  # occurrence extension
  if(has_occurExt & pos_field %in% colnames(occurExt)){
    empty_val <- occurExt[,pos_field] %in% c(NA, "")
    no_num <- grepl("[[:alpha:]]|[[:space:]]", occurExt[,pos_field])
    bad_format <- grepl("^-", occurExt[,pos_field])
    
    condition <- which(bad_format & !empty_val & !no_num)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_miscellaneous",
                                     level="error",
                                     field=pos_field,
                                     row=condition[cd],
                                     value=occurExt[,pos_field][condition[cd]],
                                     message="no negative values allowed"))
      }
    }
  }
}

# 6.6 minimum must be < maximum values
check_min_max <- function(var_min, var_max, data, QC_report, DwC_type="eventCore"){
  if(var_min %in% colnames(data) & var_max  %in% colnames(data)){
  condition <- which(data[,var_min]>data[,var_max])
  if(length(condition)>0){
    for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_miscellaneous",
                                     level="error",
                                     field=paste(DwC_type, var_min, sep=":"),
                                     row=condition[cd],
                                     value=data[,var_min][condition[cd]],
                                     message="min value larger than max value"))
      }
    }
  }
  return(QC_report)
}
#eventCore
QC_report <- check_min_max(var_min="minimumDepthInMeters", 
                           var_max="maximumDepthInMeters", 
                           data=eventCore, QC_report=QC_report, DwC_type="eventCore")
QC_report <- check_min_max(var_min="minimumElevationInMeters", 
                           var_max="maximumElevationInMeters", 
                           data=eventCore, QC_report=QC_report, DwC_type="eventCore")
QC_report <- check_min_max(var_min="minimumDistanceAboveSurfaceInMeters", 
                           var_max="maximumDistanceAboveSurfaceInMeters", 
                           data=eventCore, QC_report=QC_report, DwC_type="eventCore")
# occurrence extension
if(has_occurExt){
  QC_report <- check_min_max(var_min="minimumDepthInMeters", 
                           var_max="maximumDepthInMeters", 
                           data=occurExt, QC_report=QC_report, DwC_type="occurExt")
  QC_report <- check_min_max(var_min="minimumElevationInMeters", 
                           var_max="maximumElevationInMeters", 
                           data=occurExt, QC_report=QC_report, DwC_type="occurExt")
  QC_report <- check_min_max(var_min="minimumDistanceAboveSurfaceInMeters", 
                           var_max="maximumDistanceAboveSurfaceInMeters", 
                           data=occurExt, QC_report=QC_report, DwC_type="occurExt")
}



# 6.7 the " | " must be the value separator in certain fields
pipe_fields <- c("recordedBy", "preparations", "associatedMedia", "associatedReferences", "associatedTaxa", "otherCatalogNumbers", "associatedOccurrences", "associatedOrganisms", "previousIdentifications", "higherGeography", "georeferencedBy", "georeferenceSources", "typeStatus", "identificationReferences", "higherClassification", "measurementDeterminedBy")
check_pipe_sep <- function(pipefield, data, QC_report, DwC_type="eventCore"){
  if(pipefield %in% colnames(data)){
    missing_val <- data[,pipefield] %in% c(NA, "") #the empty fields, was checked before
    no_pipe <- grepl("\\:|,|;|-|_", data[,pipefield]) & !grepl("\\|", data[,pipefield])
    condition <- which(no_pipe & !missing_val)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_miscellaneous",
                                     level="warning",
                                     field=paste(DwC_type, pipefield, sep=":"),
                                     row=condition[cd],
                                     value=data[,pipefield][condition[cd]],
                                     message="no use of ( | ) for value separator"))
      }
    }
  }
  return(QC_report)
}

for(pipefield in pipe_fields){
  QC_report <- check_pipe_sep(pipefield, data=eventCore, QC_report=QC_report, DwC_type="eventCore")
  if(has_occurExt){
    QC_report <- check_pipe_sep(pipefield, data=occurExt, QC_report=QC_report, DwC_type="occurExt")
  }
}

# 6.8 data in individualCount and occurrenceStatus must match up
if(has_occurExt){
  if("individualCount" %in% colnames(occurExt) &
   "occurrenceStatus" %in% colnames(occurExt) &
   "scientificName" %in% colnames(occurExt)){
    missing_val_indCount <- occurExt$individualCount %in% c(NA, "")
    missing_val_occStat <- occurExt$occurrenceStatus %in% c(NA, "")
    missing_val_sciName <- occurExt$scientificName %in% c(NA, "")
  
    zero_indCount <- as.numeric(occurExt$individualCount) == 0
    abs_occStat <- occurExt$occurrenceStatus == "absent"

    bad_indCount <- which(!zero_indCount & missing_val_sciName & abs_occStat)
  
    # zero indCount with present occStat 
    condition <- which(zero_indCount & !abs_occStat)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_miscellaneous",
                                     level="error",
                                     field="occurExt:occurrenceStatus",
                                     row=condition[cd],
                                     value=NA,
                                     message="zero individualCount with occurrenceStatus present"))
      }
    }
    # non-zero indCount with absence or no sciName
    condition <- which(!zero_indCount & (missing_val_sciName | abs_occStat))
      if(length(condition)>0){
        for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                          data.frame(section="QC_miscellaneous",
                                     level="error",
                                     field="occurExt:occurrenceStatus",
                                     row=condition[cd],
                                     value=NA,
                                     message="individualCount > 0 with occurrenceStatus absent"))
      }
    }
  }
}


#ToDo
#ULRS and DOIs in fields correctly formatted?

  
# 6.9 return output
if(nrow(QC_report[QC_report$section=="QC_miscellaneous",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_miscellaneous",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}

```


## Part 7. QC on typos and pseudorepliactes
Pseudorepliacates are variants of strings that have an identical meaning but differ in notation. Here, strings in different fields are matched and flagged as potential pseudoreplicates if they have at leas 1, at most 2 characters difference (e.g capitals, typos,...) and do not differ more than 25% (to prevent matches between short words with some characters in common). In case a string is made up of multiple words separacted by spaces, matches are also found if the words have a different order (allowing 1-2 characters and 25% difference between words).

```{r QC_pseudoreplicates, echo = FALSE, results='asis'}
# 7.1 pseudo replicate variants 
# pseudo replicate variants are here defined as strings that have at most 2 character difference,
# but also differ no more than 25%, and/or are switched in order if there are multiple words in the string
typoFields <- c("scientificName", "verncularName", "identificationQualifier", "typeStatus", "identifiedBy",
                "associatedTaxa", "organismScope", "genus", "subgenus", "specificEpithet", "infraspecificEpithet",
                "samplingProtocol", "informationWithheld", "dataGeneralizations", "dynamicProperties",
                "recordedBy", "lifeStage", "reproductiveCondition", "behavior", "establishmentMeans",
                "degreeOfEstablishment", "pathway", "preparations", "disposition", "previousIdentifications",
                "organismRemarks", "habitat", "samplingEffort", 
                "location", "continent", "waterBody", "islandGroup", "island", "country", "stateProvince", "county",
                "municipality", "locality", "locationAccordingTo", 
                "georeferencedBy", "georeferenceProtocol", "georeferenceSources", "georeferenceVerificationStatus", 
                "formation", "member", "bed")

check_typos <- function(field, data, DwC_type="eventCore"){
  if(field %in% colnames(data)){
    uniques <- names(table(data[,field]))
    uniques <- uniques[!uniques %in% c(NA, "")]
    freq <- data.frame(table(data[,field]))
    freq <- freq[freq$Var1 %in% uniques,]

    QC_pseudorep <- data.frame(value_1=character(), value_2=character(), 
                            frequency_1=character(), frequency_2=character())
    for(targetString in uniques){
      if(!targetString %in% c(QC_pseudorep$value_1, QC_pseudorep$value_2)){
        matchLibrary <-uniques[nchar(uniques) %in% (nchar(targetString)-2:nchar(targetString)+2)]
        targetString_split <- str_split(targetString, " ")[[1]]
        for(matchString in matchLibrary){
          matchString_split <- str_split(matchString, " ")[[1]]
          matches_c <-c()
          for(targetSubString in targetString_split){
            if(targetSubString != "" & !is.na(targetSubString)){
              matches_c <- c(matches_c, 
                           any(agrepl(targetSubString, matchString_split, 2) & #max 2 character different
                                 agrepl(targetSubString, matchString_split, 0.25))) #max 25% different
            }
          }
          if(all(matches_c) & 
            targetString != matchString & 
            2*length(matches_c)==(length(targetString_split)+length(matchString_split))){
            QC_pseudorep <- rbind(QC_pseudorep, data.frame(value_1=targetString, 
                                                    value_2=matchString, 
                                                    frequency_1=freq[freq$Var1 == targetString,]$Freq,
                                                    frequency_2=freq[freq$Var1 == matchString,]$Freq))
          }
        }
      }
    }
    # return output
    if(nrow(QC_pseudorep)>0){
      message(paste("Warning: in ", DwC_type, ":", field,
                    " some values were suspiciously alike, and may be pseudoreplicates:\n", sep=""))
      print(knitr::kable(QC_pseudorep))
      cat('\n')
      #print(QC_pseudorep)
    }
  }
}

for(field in typoFields){
  check_typos(field, data=eventCore, DwC_type="eventCore")
  check_typos(field, data=occurExt, DwC_type="occurExt")
}

```

``` {r QC_finalize, echo = FALSE}
if(any("fatal_error" %in% QC_report$level)){
  QC_final <- "The dataset has **NOT passed** the QC\nReason:\n"
  fatal <- TRUE
}else{
  QC_final <- "Dataset has **PASSED** the QC!"
  fatal <- FALSE
}

```

# Conclusion: `r QC_final`

`r if(fatal){knitr::kable(QC_report[QC_report$level=="fatal_error",colnames(QC_report) %in% c("field","row", "value", "message")]) }`

