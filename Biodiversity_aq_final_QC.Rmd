---
title: "Final Quality Controll Report"
author: "Maxime Sweetlove"
output: pdf_document
---

`r Sys.Date()`

### 0.1. Summary
This is the standardized protocol to do a final Quality Control (QC) on biodiversity data before publishing to ipt.biodiversity.aq. This protocol assums the data has already been standardized into DarwinCore CSV files, with columns as DarwinCore terms and rows as occurrences or events.

### 0.2. How to use this protocol
Step 0: make sure R markdown and Knitr work
Step 1: install all required libraries and check if they work (see code section 0.3)
Step 2: change the working directory and file name to the dataset that needs to be checked (see code section 0.4)
Step 3: Knit the document, a PDF report of the QC will be generated.
Notice: Fixing issues goes beyond the scope of this protocol and need to be adressed by the user.

```{r setting_up, echo=FALSE, message=FALSE}
knitr::opts_chunk$set(tidy = TRUE, tidy.opts = list(comment = FALSE), echo=FALSE) #global options for knittr
# 0.3. Setting up the environment
defaultW <- getOption("warn") # to supress warnings when loading a package
options(warn = -1) 
library(obistools)
library(MicrobeDataTools)

options(warn = defaultW)

# read the library of DarwinCore terms
dwc_lib <- MicrobeDataTools::TermsLib

# to collect all the issues
QC_report <- data.frame(section=character(), #the type of QC that was done
                        level=character(), #either recommendation, warning, error or fatal error
                        field=character(), # the column name causing an issue
                        row=character(),  # the now number where the issue occured
                        value=character(), # the value of the field that causes the issue
                        message=character()) #the message explaining the issue

```


```{r read_data, echo = FALSE}
# 0.4. Reading the data.
##########################################
# START CHANGING CODE HERE
datasetDir <- "/Users/msweetlove/Royal Belgian Institute of Natural Sciences/Royal Belgian Institute of Natural Sciences/Anton Van de Putte - data_processing/03_processed/Lindsay/1_03_processed"
#to list the files in the directory
#list.files(datasetDir)
# get the file name
fileName <- "Lindsay_ANGELbase.csv"
# STOP CHANGING CODE HERE
##########################################

# read the data
occurCore<- read.csv(paste(datasetDir, fileName, sep="/"))
```


# Quality Control report for the dataset `r fileName` .

## Part 1. QC on DarwinCore
This part of the QC focuses on the format of the data and the correct implementation of DarwinCore. The table below displays the issues that were discovered.
```{r QC_DwC, echo = FALSE}
# 1.1. are all column names DarwinCore terms?
condition <- setdiff(colnames(occurCore), dwc_lib[dwc_lib$DwC_Occurrence>0,]$name)
if(length(condition)>0){
  for(cd in 1:length(condition)){
    QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="fatal_error",
                                  field=condition[cd],
                                  row=NA,
                                  value=NA,
                                  message="not a DarwinCore term"))
  }
}

# 1.2. are all the mandatory columns present?
# required by OBIS: 
required <- c("eventDate", "decimalLongitude", "decimalLatitude",  
              "scientificName", "scientificNameID", "occurrenceStatus", "basisOfRecord")

condition <- length(intersect(colnames(occurCore), required)) == length(required)
if(!condition){
  missing <- setdiff(required, colnames(occurCore))
    for(ms in missing){
    QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="fatal_error",
                                  field=ms,
                                  row=NA,
                                  value=NA,
                                  message="Required term missing"))
  }
}

# 1.3. any missing values in the required terms?
for(field in required){
  if(field %in% colnames(occurCore)){
    condition <- which(occurCore[,field] %in% c(NA, ""))
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="warning",
                                  field=field,
                                  row=condition[cd],
                                  value=NA,
                                  message="missing value for required term"))
      }
    }
  }
}


# 1.4. are there empty columns or rows?
condition <- which(colSums(is.na(occurCore)) >= (nrow(occurCore)))
if(length(condition)>0){
  for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="warning",
                                  field=colnames(occurCore)[condition[cd]],
                                  row=NA,
                                  value=NA,
                                  message="This column is empty"))
  }
}

condition <- which(rowSums(is.na(occurCore)) >= (ncol(occurCore)))
if(length(condition)>0){
  for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="warning",
                                  field=NA,
                                  row=condition[cd],
                                  value=NA,
                                  message="This row is empty"))
  }
}


# 1.5. is basisOfRecord correctly formatted?
if("basisOfRecord" %in% colnames(occurCore)){
  condition <- 
  occurCore$basisOfRecord %in% c("HumanObservation", "PreservedSpecimen", "FossilSpecimen", "LivingSpecimen", "MaterialSample", "Event", "MachineObservation", "Taxon", "Occurrence")
  if(any(!condition)){
    cond2 <- which(!occurCore$basisOfRecord %in% c("HumanObservation", "PreservedSpecimen", "FossilSpecimen", "LivingSpecimen", "MaterialSample", "Event", "MachineObservation", "Taxon", "Occurrence"))
      for(cd in 1:length(cond2)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="fatal_error",
                                  field="basisOfRecord",
                                  row=cond2[cd],
                                  value=occurCore$basisOfRecord[cond2[cd]],
                                  message="Incorrect value for basisOfRecord"))
    }
  }
}

# 1.6. are recommended terms missing?
recommended <- c("coordinateUncertaintyInMeters", "samplingProtocol", "locality", "rights", "license", "modified", "year", "month", "day", "datasetID")
#ToDo

# 1.7. return output
if(nrow(QC_report[QC_report$section=="QC_DwC",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_DwC",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}
```



## Part 2. QC on correct use of identifiers
The content of different ID fields (e.g. occurrenceID) is evaluated. Issues may include duplicated values or erroneous references of IDs between tables. The table below displays the issues that were discovered.
``` {r QC_IDs, echo = FALSE}
# 2.1. are all occurrenceIDs unique?
if("occurrenceID" %in% colnames(occurCore)){
  condition <- duplicated(occurCore$occurrenceID)
  if(any(condition)){
    cond2 <- which(duplicated(occurCore$occurrenceID))
      for(cd in 1:length(cond2)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_IDs",
                                  level="fatal_error",
                                  field="occurrenceID",
                                  row=cond2[cd],
                                  value=condition[cd],
                                  message="occurrenceID is duplicated"))
    }
  }
}

# 2.x. [for eventCore] what eventIDs are not diffrent from their parentEventID?
# which(coreEvent$eventID == coreEvent$parentEventID)

# 2.x. [for eventCore] Check if all parentEventIDs have corresponding eventIDs.
#obistools::check_eventids(tibble(coreEvent))

# 2.2 return output
if(nrow(QC_report[QC_report$section=="QC_IDs",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_IDs",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}

```


## Part 3. QC on taxonomy
The taxonomic information in the dataset is checked for correct formatting of the scientific name, and for linkage to the WoRMS taxonomic backbone (scientificNameID, formatted as urn:lsid). The table below displays the issues that were discovered.
``` {r QC_taxonomy, echo = FALSE}
# 3.1. are all scientific names correctly formatted?
tax_not_allowed <- c("sp.", "spp.",  "[0-9]", "gen. nov.", "gen nov.", "gen nov", "gen. nov", "^ ")
if("scientificName" %in% colnames(occurCore)){
  for(not_allowed in tax_not_allowed){
    condition <- which(grepl(not_allowed, occurCore$scientificName))
    if(not_allowed == "^ "){
      msg <- "leading space"
    } else{msg<-"incorrect format"}
      if(length(condition)>0){
          for(cd in 1:length(condition)){
              QC_report <- rbind(QC_report, 
                       data.frame(section="QC_taxonomy",
                                  level="warning",
                                  field="scientificName",
                                  row=condition[cd],
                                  value=occurCore$scientificName[condition[cd]],
                                  message=msg))
      }
    }
  }
}

# 3.2. are taxonIDs correctly formatted?
if("scientificNameID" %in% colnames(occurCore)){
  missing_val <- occurCore$scientificNameID %in% c(NA, "") #the empty fields, was checked before
  missing_num <- !grepl("[0-9]", occurCore$scientificNameID) #must contain numerics
  missing_format <- !grepl("urn:lsid:", occurCore$scientificNameID, fixed=T)# must start with urn:lsid:
  
  condition <- which((missing_num | missing_format) & !missing_val)
  if(length(condition)>0){
    for(cd in 1:length(condition)){
      QC_report <- rbind(QC_report, 
                         data.frame(section="QC_taxonomy",
                                    level="warning",
                                    field="scientificNameID",
                                    row=condition[cd],
                                    value= occurCore$scientificName[condition[cd]],
                                    message="incorrect format"))
    }
  }
}

# 3.2 return output
if(nrow(QC_report[QC_report$section=="QC_taxonomy",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_taxonomy",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}
```

## Part 4. QC on geography
The geographic locations of the occurrences are inspected. A common error is inflated precision (number of decimal places) of the coordinates as a result of converting from degrees-minutes-seconds to decimal degrees. Coordinates need to be rounded to the same percision as te original sample. Increasing the number of decimal places suggests the position of the occurence was more precisely measured than it actually was.

The map below allows for a visual inspection.
``` {r QC_geo_plot, echo = FALSE}
# 4.1. plot points on a map
obistools::plot_map(occurCore)
```

The table below displays the issues that were discovered.
``` {r QC_geo, echo = FALSE}
# 4.2. are coordinates too precise? more than 6 decimals may point to this
geofields<- c("decimalLatitude", "decimalLongitude")
for(geofield in geofields){
  if(geofield %in% colnames(occurCore)){
    coords_dec <- unname(sapply(occurCore[,geofield], function(x){str_split(as.character(x), "\\.")[[1]][2]}))
    coords_dec[is.na(coords_dec)] <- 0
    condition <- which(nchar(coords_dec)>6)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                         data.frame(section="QC_geo",
                                    level="warning",
                                    field=geofield,
                                    row=condition[cd],
                                    value=occurCore$decimalLatitude[condition[cd]],
                                    message="precision may be inflated"))
      }
    }
  }
}

# 4.2 return output
if(nrow(QC_report[QC_report$section=="QC_geo",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_geo",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}

```


## Part 5. date and time
Date and time values need to be formatted as followed: YYYY-MM-DD, YYYY-MM-DDThh:mm, YYYY-MM-DDThh:mmZ. Any deviation of this format will be flaged. In addition, the dates intselves are checked for obvious typos, such as years <1500 or >present, months that exceed 12 or days that exceed 31. The table below displays the issues that were discovered.
``` {r QC_date, echo = FALSE}
# 5.1. are dates formatted correctly?
# correct format YYYY-MM-DD, YYYY-MM-DDThh:mm, YYYY-MM-DDThh:mmZ
datefields <- c("eventDate", "modified", "dateIdentified")
date_pattern <- "^\\d{4}(-\\d{2}(-\\d{2}([T|\\s]\\d{2}(:\\d{2}(:\\d{2})?)?(Z|([+-]\\d{2}:?(\\d{2})?))?)?)?)?$"
for(datefield in datefields){
  if(datefield %in% colnames(occurCore)){
    wrong_date <- !grepl(date_pattern, occurCore[,datefield])
    no_date <- occurCore[,datefield] %in% c(NA, "")
      
    condition <- which(wrong_date & !no_date)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
           QC_report <- rbind(QC_report, 
                       data.frame(section="QC_date",
                                  level="warning",
                                  field=datefield,
                                  row=condition[cd],
                                  value=occurCore[condition[cd], datefield],
                                  message="invalid date format"))

      }
    }
        
    year <- unname(sapply(occurCore[,datefield], function(x){str_split(x, "-")[[1]][1]}))
    bad_year <- (year<1500 | year>as.numeric(str_split(Sys.Date(), "-")[[1]][1]))
    bad_year[is.na(bad_year)] <- FALSE
    condition <- which(bad_year & !wrong_date & !no_date)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                       data.frame(section="QC_date",
                                  level="warning",
                                  field=datefield,
                                  row=condition[cd],
                                  value=occurCore[condition[cd], datefield],
                                  message="invalid year (<1500 or >present)"))
      }
    }
    month <- unname(sapply(occurCore[,datefield], function(x){str_split(x, "-")[[1]][2]}))
    bad_month <- (month<0 | month>12)
    bad_month[is.na(bad_month)] <- FALSE
    condition <- which(bad_month & !bad_year & !wrong_date & !no_date)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                       data.frame(section="QC_date",
                                  level="warning",
                                  field=datefield,
                                  row=condition[cd],
                                  value=occurCore[condition[cd], datefield],
                                  message="invalid month (<0 or >12)"))

      }
    }
    day <- unname(sapply(occurCore[,datefield], function(x){str_split(x, "-")[[1]][3]}))
    bad_day <- (day<0 | day>31)
    bad_day[is.na(bad_day)] <- FALSE
    condition <- which(bad_day & !bad_month & !bad_year & !wrong_date & !no_date)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                       data.frame(section="QC_date",
                                  level="warning",
                                  field=datefield,
                                  row=condition[cd],
                                  value=occurCore[condition[cd], datefield],
                                  message="invalid day (<0 or >31)"))
      }
    }
  }
}

# year, month, day
# ToDo

# 5.2 return output
if(nrow(QC_report[QC_report$section=="QC_date",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_date",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}

```


## Part 6. QC on the content of some other fields.
Some fields, such as dynamicProperties, footprintWKT or numeric fields require a specificly formatted content. This is checked in this section. The table below displays the issues that were discovered.
``` {r QC_miscellaneous, echo = FALSE}
# 6.1. is dynamicProperties formatted correctly?
# correct format: {field1:value1}, {field2:value2}
if("dynamicProperties" %in% colnames(occurCore)){
  empty_val <- occurCore$dynamicProperties %in% c(NA, "")
  bad_format <- !grepl("^\\{.*\\:.*\\}$", occurCore$dynamicProperties)
  condition <- which(bad_format & !empty_val)
  if(length(condition)>0){
    for(cd in 1:length(condition)){
      QC_report <- rbind(QC_report, 
                         data.frame(section="QC_miscellaneous",
                                    level="error",
                                    field="dynamicProperties",
                                    row=condition[cd],
                                    value=occurCore$dynamicProperties[condition[cd]],
                                    message="incorrect format for dynamicProperties"))
    }
  }
}

# 6.2. is footprintWKT formatted correctly?
# correct format: POINT (p1, p2), LINESTRING, POLYGON, MULTiPOINT, MULTILINESTRING, MULTIPOLYGON
if("footprintWKT" %in% colnames(occurCore)){
  empty_val <- occurCore$footprintWKT %in% c(NA, "")
  bad_format <- !grepl("POINT|LINESTRING|POLYGON|MULTiPOINT|MULTILINESTRING|MULTIPOLYGON", occurCore$footprintWKT)
  condition <- which(bad_format & !empty_val)
  if(length(condition)>0){
    for(cd in 1:length(condition)){
      QC_report <- rbind(QC_report, 
                        data.frame(section="QC_miscellaneous",
                                   level="warning",
                                   field="footprintWKT",
                                   row=condition[cd],
                                   value=occurCore$footprintWKT[condition[cd]],
                                   message="incorrect format for WKT"))
    }
  }
}

# 6.3. is occurrenceStatus formatted correctly?
# correct format: present, absent
if("occurrenceStatus" %in% colnames(occurCore)){
  empty_val <- occurCore$occurrenceStatus %in% c(NA, "")
  bad_format <- !grepl("^present$|^absent$", occurCore$occurrenceStatus)
  condition <- which(bad_format & !empty_val)
  if(length(condition)>0){
    for(cd in 1:length(condition)){
      QC_report <- rbind(QC_report, 
                        data.frame(section="QC_miscellaneous",
                                   level="error",
                                   field="occurrenceStatus",
                                   row=condition[cd],
                                   value=occurCore$occurrenceStatus[condition[cd]],
                                   message="incorrect value for occurrenceStatus"))
    }
  }
}

# 6.4. are there non-numeric values in numeric fields?
num_fields <- c("decimalLatitude", "decimalLongitude", "minimumDepthInMeters", "maximumDepthInMeters", 
               "organismQuantity", "year", "month", "day", "individualCount", "maximumElevationInMeters",
               "minimumElevationInMeters", "coordinateUncertaintyInMeters", "namePublishedInYear")
for(num_field in num_fields){
  if(num_field %in% colnames(occurCore)){
    empty_val <- occurCore[,num_field] %in% c(NA, "")
    bad_format <- grepl("[[:alpha:]]|[[:space:]]", occurCore[,num_field])
    condition <- which(bad_format & !empty_val)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_miscellaneous",
                                     level="error",
                                     field=num_field,
                                     row=condition[cd],
                                     value=occurCore[,num_field][condition[cd]],
                                     message="non numeric value"))
      }
    }
  }
}

# 6.5 return output
if(nrow(QC_report[QC_report$section=="QC_miscellaneous",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_miscellaneous",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}

```

``` {r QC_finalize, echo = FALSE}
if(any("fatal_error" %in% QC_report$level)){
  QC_final <- "The dataset has **NOT passed** the QC\nReason:\n"
  fatal <- TRUE
}else{
  QC_final <- "Dataset has **PASSED** the QC!"
  fatal <- FALSE
}

```



# Conclusion: `r QC_final`

`r if(fatal){knitr::kable(QC_report[QC_report$level=="fatal_error",colnames(QC_report) %in% c("field","row", "value", "message")]) }`

