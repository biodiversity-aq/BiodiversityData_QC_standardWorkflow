---
title: "Data validation protocol for DarwinCore Occurrence Core"
author: "Maxime Sweetlove"
output: pdf_document
---

`r Sys.Date()`

### 0.1. Summary
This is the standardized protocol to validate wether biodiversity data conforms to DarwinCore before publishing to ipt.biodiversity.aq. This protocol assums the data has already been qualty controlled and standardized into DarwinCore Occurrence Core CSV file (with columns as DarwinCore terms and rows as occurrences).

The protocol is fully automated, following the phylosophy that computers need to be able to parse the understand the data to be able to querry and subset it for human use. Any potential issues are flagged in the PDF report that is generated by running knitr.

### 0.2. How to use this protocol
Step 0: make sure R markdown and Knitr work*. 
Step 1: install all required libraries and check if they work (see code section 0.3).**
Step 2: change the working directory and file name to the dataset that needs to be checked (see code section 0.4)
Step 3: Knit the document, a PDF report of the QC will be generated.
Notice: Fixing issues goes beyond the scope of this protocol and need to be adressed by the user.

*If you can't get R markdown and Knitr to work, code blocks can also be copy-pasted into an R script and run like that.
**If you have trouble installing the MicrobeDataTools package, alternatively the TermsLib table can be downloaded and used locally.

```{r setting_up, echo=FALSE, message=FALSE}
knitr::opts_chunk$set(tidy = TRUE, tidy.opts = list(comment = FALSE), echo=FALSE) #global options for knittr
# 0.3. Setting up the environment
defaultW <- getOption("warn") # to supress warnings when loading a package
options(warn = -1) 
library(obistools)
library(MicrobeDataTools)

options(warn = defaultW)

# read the library of DarwinCore terms
dwc_lib <- MicrobeDataTools::TermsLib

# to collect all the issues
QC_report <- data.frame(section=character(), #the type of QC that was done
                        level=character(), #either recommendation, warning, error or fatal error
                        field=character(), # the column name causing an issue
                        row=character(),  # the now number where the issue occured
                        value=character(), # the value of the field that causes the issue
                        message=character()) #the message explaining the issue

```


```{r read_data, echo = FALSE}
# 0.4. Reading the data.
##########################################
# START CHANGING CODE HERE
datasetDir <- "/Users/msweetlove/Royal Belgian Institute of Natural Sciences/Royal Belgian Institute of Natural Sciences/Anton Van de Putte - data_processing/03_processed/Lindsay/1_03_processed"
#to list the files in the directory
#list.files(datasetDir)
# get the file name
fileName <- "Lindsay_ANGELbase.csv"
# STOP CHANGING CODE HERE
##########################################

# read the data
occurCore<- read.csv(paste(datasetDir, fileName, sep="/"))
```


# Quality Control report for the dataset `r fileName` .

## Part 1. QC on DarwinCore
This part of the QC focuses on the format of the data as a DarwinCore Occurrence Core file. 
The table below displays the issues that were discovered.
```{r QC_DwC, echo = FALSE}
# 1.1. are all column names DarwinCore terms?
condition <- setdiff(colnames(occurCore), dwc_lib[dwc_lib$DwC_Occurrence>0,]$name)
if(length(condition)>0){
  for(cd in 1:length(condition)){
    QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="fatal_error",
                                  field=condition[cd],
                                  row=NA,
                                  value=NA,
                                  message="not a DarwinCore term"))
  }
}

# 1.2. are all the mandatory columns present?
# required by OBIS: 
required <- c("eventDate", "decimalLongitude", "decimalLatitude",  
              "scientificName", "scientificNameID", "occurrenceStatus", "basisOfRecord")

condition <- length(intersect(colnames(occurCore), required)) == length(required)
if(!condition){
  missing <- setdiff(required, colnames(occurCore))
    for(ms in missing){
    QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="fatal_error",
                                  field=ms,
                                  row=NA,
                                  value=NA,
                                  message="Required term missing"))
  }
}

# 1.3. any missing values in the required terms?
for(field in required){
  if(field %in% colnames(occurCore)){
    condition <- which(occurCore[,field] %in% c(NA, ""))
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="warning",
                                  field=field,
                                  row=condition[cd],
                                  value=NA,
                                  message="missing value for required term"))
      }
    }
  }
}


# 1.4. are there empty columns or rows?
condition <- which(colSums(is.na(occurCore)) >= (nrow(occurCore)))
if(length(condition)>0){
  for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="warning",
                                  field=colnames(occurCore)[condition[cd]],
                                  row=NA,
                                  value=NA,
                                  message="This column is empty"))
  }
}

condition <- which(rowSums(is.na(occurCore)) >= (ncol(occurCore)))
if(length(condition)>0){
  for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="warning",
                                  field=NA,
                                  row=condition[cd],
                                  value=NA,
                                  message="This row is empty"))
  }
}


# 1.5. is basisOfRecord correctly formatted?
if("basisOfRecord" %in% colnames(occurCore)){
  condition <- 
  occurCore$basisOfRecord %in% c("HumanObservation", "PreservedSpecimen", "FossilSpecimen", "LivingSpecimen", "MaterialSample", "Event", "MachineObservation", "Taxon", "Occurrence")
  if(any(!condition)){
    cond2 <- which(!occurCore$basisOfRecord %in% c("HumanObservation", "PreservedSpecimen", "FossilSpecimen", "LivingSpecimen", "MaterialSample", "Event", "MachineObservation", "Taxon", "Occurrence"))
      for(cd in 1:length(cond2)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="fatal_error",
                                  field="basisOfRecord",
                                  row=cond2[cd],
                                  value=occurCore$basisOfRecord[cond2[cd]],
                                  message="Incorrect value for basisOfRecord"))
    }
  }
}

# 1.6. are recommended terms missing?
recommended <- c("coordinateUncertaintyInMeters", "samplingProtocol", "locality", "rights", "license", "modified", "year", "month", "day", "datasetID")
condition <- length(intersect(colnames(occurCore), recommended)) == length(recommended)
if(!condition){
  missing <- setdiff(recommended, colnames(occurCore))
    for(ms in missing){
    QC_report <- rbind(QC_report, 
                       data.frame(section="QC_DwC",
                                  level="warning",
                                  field=ms,
                                  row=NA,
                                  value=NA,
                                  message="Recommended term missing"))
  }
}

# 1.7. return output
if(nrow(QC_report[QC_report$section=="QC_DwC",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_DwC",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}
```


## Part 2. QC on correct use of identifiers
The content of different ID fields (e.g. occurrenceID) is evaluated. Issues may include duplicated values or erroneous references of IDs between tables. The table below displays the issues that were discovered.
``` {r QC_IDs, echo = FALSE}
# 2.1. are all occurrenceIDs unique?
if("occurrenceID" %in% colnames(occurCore)){
  condition <- duplicated(occurCore$occurrenceID)
  if(any(condition)){
    cond2 <- which(duplicated(occurCore$occurrenceID))
      for(cd in 1:length(cond2)){
        QC_report <- rbind(QC_report, 
                       data.frame(section="QC_IDs",
                                  level="fatal_error",
                                  field="occurrenceID",
                                  row=cond2[cd],
                                  value=condition[cd],
                                  message="occurrenceID is duplicated"))
    }
  }
}

# 2.2. no spaces, hyphens, ... in occurrenceIDs
if("occurrenceID" %in% colnames(occurCore)){
  condition <- which(!grepl("^([[:alnum:]]|:|_)*$", occurCore$occurrenceID))
    if(length(condition)>0){
    for(cd in 1:length(condition)){
      QC_report <- rbind(QC_report, 
                         data.frame(section="QC_IDs",
                                    level="error",
                                    field="occurrenceID",
                                    row=condition[cd],
                                    value= occurCore$occurrenceID[condition[cd]],
                                    message="illigal character"))
    }
  }
}

# 2.x. [for eventCore] what eventIDs are not diffrent from their parentEventID?
# which(coreEvent$eventID == coreEvent$parentEventID)

# 2.x. [for eventCore] Check if all parentEventIDs have corresponding eventIDs.
#obistools::check_eventids(tibble(coreEvent))

# 2.3 return output
if(nrow(QC_report[QC_report$section=="QC_IDs",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_IDs",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}

```


## Part 3. QC on taxonomy
The taxonomic information in the dataset is checked for correct formatting of the scientific name, and for linkage to the WoRMS taxonomic backbone (scientificNameID, formatted as urn:lsid). The table below displays the issues that were discovered.
``` {r QC_taxonomy, echo = FALSE}
# 3.1. are all scientific names correctly formatted?
not_allowed <- "sp.$|sp$|spp.$|spp$|[0-9]|(gen(.) nov)|(gen nov)|(gen(.)nov)|^ | $|cf|var$|var.$|^[a-z]|[[:punct:]]"
if("scientificName" %in% colnames(occurCore)){
    missing_val <- occurCore$scientificName %in% c(NA, "") 
    bad_format <- grepl(not_allowed, occurCore$scientificName)
    condition <- which(bad_format & !missing_val)
    if(length(condition)>0){
        for(cd in 1:length(condition)){
            QC_report <- rbind(QC_report, 
                      data.frame(section="QC_taxonomy",
                                level="error",
                                field="scientificName",
                                row=condition[cd],
                                value=occurCore$scientificName[condition[cd]],
                                message="incorrect format"))
    }
  }
}

# 3.2. are taxonIDs correctly formatted?
if("scientificNameID" %in% colnames(occurCore)){
  missing_val <- occurCore$scientificNameID %in% c(NA, "") #the empty fields, was checked before
  missing_num <- !grepl("[0-9]", occurCore$scientificNameID) #must contain numerics
  missing_format <- !grepl("urn:lsid:", occurCore$scientificNameID, fixed=T)# must start with urn:lsid:
  
  condition <- which((missing_num | missing_format) & !missing_val)
  if(length(condition)>0){
    for(cd in 1:length(condition)){
      QC_report <- rbind(QC_report, 
                         data.frame(section="QC_taxonomy",
                                    level="warning",
                                    field="scientificNameID",
                                    row=condition[cd],
                                    value= occurCore$scientificName[condition[cd]],
                                    message="incorrect format"))
    }
  }
}

# 3.2 return output
if(nrow(QC_report[QC_report$section=="QC_taxonomy",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_taxonomy",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}
```

## Part 4. QC on geography
The geographic locations of the occurrences are inspected. A common error is inflated precision (number of decimal places) of the coordinates as a result of converting from degrees-minutes-seconds to decimal degrees. Coordinates need to be rounded to the same percision as te original sample. Increasing the number of decimal places suggests the position of the occurence was more precisely measured than it actually was.

The map below allows for a visual inspection.
``` {r QC_geo_plot, echo = FALSE}
# 4.1. plot points on a map
obistools::plot_map(occurCore)
```

The table below displays the issues that were discovered.
``` {r QC_geo, echo = FALSE}
# 4.2. are coordinates too precise? more than 6 decimals may point to this
geofields<- c("decimalLatitude", "decimalLongitude")
for(geofield in geofields){
  if(geofield %in% colnames(occurCore)){
    coords_dec <- unname(sapply(occurCore[,geofield], function(x){str_split(as.character(x), "\\.")[[1]][2]}))
    coords_dec[is.na(coords_dec)] <- 0
    condition <- which(nchar(coords_dec)>6)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                         data.frame(section="QC_geo",
                                    level="warning",
                                    field=geofield,
                                    row=condition[cd],
                                    value=occurCore$decimalLatitude[condition[cd]],
                                    message="precision may be inflated"))
      }
    }
  }
}

# 4.3 return output
if(nrow(QC_report[QC_report$section=="QC_geo",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_geo",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}

```


## Part 5. date and time
Date and time values need to be formatted as followed: YYYY-MM-DD, YYYY-MM-DDThh:mm, YYYY-MM-DDThh:mmZ. Any deviation of this format will be flaged. In addition, the dates intselves are checked for obvious typos, such as years <1500 or >present, months that exceed 12 or days that exceed 31. The table below displays the issues that were discovered.
``` {r QC_date, echo = FALSE}
# 5.1. are dates formatted correctly?
# correct format YYYY-MM-DD, YYYY-MM-DDThh:mm, YYYY-MM-DDThh:mmZ
datefields <- c("eventDate", "modified", "dateIdentified")
date_pattern <- "^\\d{4}(-\\d{2}(-\\d{2}([T|\\s]\\d{2}(:\\d{2}(:\\d{2})?)?(Z|([+-]\\d{2}:?(\\d{2})?))?)?)?)?$"
for(datefield in datefields){
  if(datefield %in% colnames(occurCore)){
    wrong_date <- !grepl(date_pattern, occurCore[,datefield])
    no_date <- occurCore[,datefield] %in% c(NA, "")
      
    condition <- which(wrong_date & !no_date)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
           QC_report <- rbind(QC_report, 
                       data.frame(section="QC_date",
                                  level="error",
                                  field=datefield,
                                  row=condition[cd],
                                  value=occurCore[condition[cd], datefield],
                                  message="invalid date format"))

      }
    }
        
    year <- unname(sapply(occurCore[,datefield], function(x){str_split(x, "-")[[1]][1]}))
    bad_year <- (year<1500 | year>as.numeric(str_split(Sys.Date(), "-")[[1]][1]))
    bad_year[is.na(bad_year)] <- FALSE
    condition <- which(bad_year & !wrong_date & !no_date)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                       data.frame(section="QC_date",
                                  level="warning",
                                  field=datefield,
                                  row=condition[cd],
                                  value=occurCore[condition[cd], datefield],
                                  message="invalid year (<1500 or >present)"))
      }
    }
    month <- unname(sapply(occurCore[,datefield], function(x){str_split(x, "-")[[1]][2]}))
    bad_month <- (month<0 | month>12)
    bad_month[is.na(bad_month)] <- FALSE
    condition <- which(bad_month & !bad_year & !wrong_date & !no_date)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                       data.frame(section="QC_date",
                                  level="warning",
                                  field=datefield,
                                  row=condition[cd],
                                  value=occurCore[condition[cd], datefield],
                                  message="invalid month (<0 or >12)"))

      }
    }
    day <- unname(sapply(occurCore[,datefield], function(x){str_split(x, "-")[[1]][3]}))
    bad_day <- (day<0 | day>31)
    bad_day[is.na(bad_day)] <- FALSE
    condition <- which(bad_day & !bad_month & !bad_year & !wrong_date & !no_date)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
          QC_report <- rbind(QC_report, 
                       data.frame(section="QC_date",
                                  level="warning",
                                  field=datefield,
                                  row=condition[cd],
                                  value=occurCore[condition[cd], datefield],
                                  message="invalid day (<0 or >31)"))
      }
    }
  }
}

# 5.2. are years formatted correctly?
if("year" %in% colnames(occurCore)){
    empty_val <- occurCore$year %in% c(NA, "")
    bad_format <- !grepl("^[1-2][0-9]{3}$|^[1-2][0-9]{3}/[1-2][0-9]{3}$",occurCore$year)
    condition <- which(bad_format & !empty_val)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_date",
                                     level="warning",
                                     field="year",
                                     row=condition[cd],
                                     value=occurCore$year[condition[cd]],
                                     message="incorrect format or value"))
      }
    }
    # for ranges YYYY/YYYY: check if year1 < year2
    date_ranges <- grep("^[1-2][0-9]{3}/[1-2][0-9]{3}$",occurCore$year)
    for(date_row in date_ranges){
      date_x <- str_split(as.character(occurCore$year[date_row]), "/")[[1]]
      if(date_x[1]>=date_x[2]){
        QC_report <- rbind(QC_report, 
                         data.frame(section="QC_date",
                                     level="warning",
                                     field="year",
                                     row=date_row,
                                     value=occurCore$year[date_row],
                                     message="year1 >= year2"))
    }
  }
}

# 5.3. are months formatted correctly?
if("month" %in% colnames(occurCore)){
    empty_val <- occurCore$month %in% c(NA, "")
    pattern_single <- "^[0-9]$|^[0][0-9]$|^[1][0-2]$"
    pattern_range1 <- "^(([0-9])|([1][0-2]))/(([0-9])|([1][0-2]))$"
    pattern_range2 <- "^(([0][0-9])|([1][0-2]))/(([0][0-9])|([1][0-2]))$"
    bad_format <- !grepl(paste(pattern_single, pattern_range1, pattern_range2, sep="|"),
                         occurCore$month)
    condition <- which(bad_format & !empty_val)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_date",
                                     level="warning",
                                     field="month",
                                     row=condition[cd],
                                     value=occurCore$month[condition[cd]],
                                     message="incorrect format or value"))
      }
    }
}

# 5.4. are days formatted correctly?
if("day" %in% colnames(occurCore)){
    empty_val <- occurCore$day %in% c(NA, "")
    pattern_single <- "^[0-9]$|[0-2][0-9]$|^[3][0-1]$"
    pattern_range1 <- "^([0-9]|([1-2][0-9])|([3][0-1]))/([0-9]|([1-2][0-9])|([3][0-1]))$"
    pattern_range2 <- "^(([0-2][0-9])|([3][0-1]))/(([0-2][0-9])|([3][0-1]))$"
    bad_format <- !grepl(paste(pattern_single, pattern_range1, pattern_range2, sep="|"),
                         occurCore$day)
    condition <- which(bad_format & !empty_val)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_date",
                                     level="warning",
                                     field="day",
                                     row=condition[cd],
                                     value=occurCore$day[condition[cd]],
                                     message="incorrect format or value"))
      }
    }
}


# 5.5. return output
if(nrow(QC_report[QC_report$section=="QC_date",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_date",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}

```


## Part 6. QC on the content of some other fields.
Some fields, such as dynamicProperties, footprintWKT or numeric fields require a specificly formatted content. This is checked in this section. The table below displays the issues that were discovered.
``` {r QC_miscellaneous, echo = FALSE}
# 6.1. is dynamicProperties formatted correctly?
# correct format: {field1:value1}, {field2:value2}
if("dynamicProperties" %in% colnames(occurCore)){
  empty_val <- occurCore$dynamicProperties %in% c(NA, "")
  bad_format <-   !grepl("^\\{.*\\:.*\\}$", occurCore$dynamicProperties) & #start with {, end with }
                      grepl("( \\})", occurCore$dynamicProperties) & #no trailing space
                      grepl("(\\: )", occurCore$dynamicProperties) & #no trailing space
                      grepl("( \\:)", occurCore$dynamicProperties) #no leading space

  condition <- which(bad_format & !empty_val)
  if(length(condition)>0){
    for(cd in 1:length(condition)){
      QC_report <- rbind(QC_report, 
                         data.frame(section="QC_miscellaneous",
                                    level="error",
                                    field="dynamicProperties",
                                    row=condition[cd],
                                    value=occurCore$dynamicProperties[condition[cd]],
                                    message="incorrect format for dynamicProperties"))
    }
  }
}

# 6.2. is footprintWKT formatted correctly? Is the precision believabe?
# correct format: POINT (p1, p2), LINESTRING, POLYGON, MULTiPOINT, MULTILINESTRING, MULTIPOLYGON
if("footprintWKT" %in% colnames(occurCore)){
  empty_val <- occurCore$footprintWKT %in% c(NA, "")
  bad_format <- !grepl("POINT|LINESTRING|POLYGON|MULTiPOINT|MULTILINESTRING|MULTIPOLYGON", occurCore$footprintWKT)

  coords_dec <- unname(sapply(occurCore$footprintWKT, function(x){str_split(as.character(x), "\\.")[[1]][2]})) 
  coords_dec <- unname(sapply(coords_dec, function(x){str_split(as.character(x), " ")[[1]][1]})) 
  coords_dec[is.na(coords_dec)] <- 0
  too_precise <- which(nchar(coords_dec)>6)

  condition <- which(bad_format | too_precise & !empty_val)
  if(length(condition)>0){
    for(cd in 1:length(condition)){
      QC_report <- rbind(QC_report, 
                        data.frame(section="QC_miscellaneous",
                                   level="warning",
                                   field="footprintWKT",
                                   row=condition[cd],
                                   value=occurCore$footprintWKT[condition[cd]],
                                   message="incorrect format for WKT"))
    }
  }
}

# 6.3. is occurrenceStatus formatted correctly?
# correct format: present, absent
if("occurrenceStatus" %in% colnames(occurCore)){
  empty_val <- occurCore$occurrenceStatus %in% c(NA, "")
  bad_format <- !grepl("^present$|^absent$", occurCore$occurrenceStatus)
  condition <- which(bad_format & !empty_val)
  if(length(condition)>0){
    for(cd in 1:length(condition)){
      QC_report <- rbind(QC_report, 
                        data.frame(section="QC_miscellaneous",
                                   level="error",
                                   field="occurrenceStatus",
                                   row=condition[cd],
                                   value=occurCore$occurrenceStatus[condition[cd]],
                                   message="incorrect value for occurrenceStatus"))
    }
  }
}

# 6.4. are there non-numeric values in numeric fields?
num_fields <- c("decimalLatitude", "decimalLongitude", "minimumDepthInMeters", "maximumDepthInMeters", 
               "organismQuantity",  "individualCount", "maximumElevationInMeters",
               "minimumElevationInMeters", "coordinateUncertaintyInMeters", "namePublishedInYear",
               "minimumDistanceAboveSurfaceInMeters", "maximumDistanceAboveSurfaceInMeters")
for(num_field in num_fields){
  if(num_field %in% colnames(occurCore)){
    empty_val <- occurCore[,num_field] %in% c(NA, "")
    bad_format <- grepl("[[:alpha:]]|[[:space:]]", occurCore[,num_field])
    condition <- which(bad_format & !empty_val)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_miscellaneous",
                                     level="error",
                                     field=num_field,
                                     row=condition[cd],
                                     value=occurCore[,num_field][condition[cd]],
                                     message="non numeric value"))
      }
    }
  }
}

# 6.5 are there negative values in fields that can only be positive?
pos_fields <- c("minimumDepthInMeters", "maximumDepthInMeters", 
               "organismQuantity", "individualCount", "maximumElevationInMeters",
               "minimumElevationInMeters", "coordinateUncertaintyInMeters", "namePublishedInYear", 
               "minimumDistanceAboveSurfaceInMeters", "maximumDistanceAboveSurfaceInMeters")
for(pos_field in pos_fields){
  if(pos_field %in% colnames(occurCore)){
    empty_val <- occurCore[,pos_field] %in% c(NA, "")
    no_num <- grepl("[[:alpha:]]|[[:space:]]", occurCore[,pos_field])
    bad_format <- grepl("^-", occurCore[,pos_field])
    
    condition <- which(bad_format & !empty_val & !no_num)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_miscellaneous",
                                     level="error",
                                     field=pos_field,
                                     row=condition[cd],
                                     value=occurCore[,pos_field][condition[cd]],
                                     message="no negative values allowed"))
      }
    }
  }
}

# 6.6 minimum must be < maximum values
#ToDo generalize function, add "minimumDistanceAboveSurfaceInMeters" "maximumDistanceAboveSurfaceInMeters"
if("minimumDepthInMeters" %in% colnames(occurCore) & "maximumDepthInMeters"  %in% colnames(occurCore)){
  condition <- which(occurCore$minimumDepthInMeters>=occurCore$maximumDepthInMeters)
  if(length(condition)>0){
    for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_miscellaneous",
                                     level="error",
                                     field="minimumDepthInMeters",
                                     row=condition[cd],
                                     value=occurCore$minimumDepthInMeters[condition[cd]],
                                     message="value larger than maximumDepthInMeters"))
    }
  }
}
if("minimumElevationInMeters" %in% colnames(occurCore) & "maximumElevationInMeters"  %in% colnames(occurCore)){
  condition <- which(occurCore$minimumElevationInMeters>=occurCore$maximumElevationInMeters)
  if(length(condition)>0){
    for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_miscellaneous",
                                     level="error",
                                     field="minimumElevationInMeters",
                                     row=condition[cd],
                                     value=occurCore$minimumElevationInMeters[condition[cd]],
                                     message="value larger than maximumElevationInMeters"))
    }
  }
}
  

# 6.7 the " | " must be the value separator in certain fields
pipe_fields <- c("recordedBy", "preparations", "associatedMedia", "associatedReferences", "associatedTaxa", "otherCatalogNumbers", "associatedOccurrences", "associatedOrganisms", "previousIdentifications", "higherGeography", "georeferencedBy", "georeferenceSources", "typeStatus", "identificationReferences", "higherClassification", "measurementDeterminedBy")
for(pipe_field in pipe_fields){
  if(pipe_field %in% colnames(occurCore)){
    missing_val <- occurCore[,pipe_field] %in% c(NA, "") #the empty fields, was checked before
    no_pipe <- grepl("\\:|,|;|-|_", occurCore[,pipe_field]) & !grepl("\\|", occurCore[,pipe_field])
    condition <- which(no_pipe & !missing_val)
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                          data.frame(section="QC_miscellaneous",
                                     level="warning",
                                     field=pipe_field,
                                     row=condition[cd],
                                     value=occurCore[,pipefield][condition[cd]],
                                     message="no use of ( | ) for value separator"))
      }
    }
  }
}

# 6.8 data in individualCount and occurrenceStatus must match up
if("individualCount" %in% colnames(occurCore) &
   "occurrenceStatus" %in% colnames(occurCore) &
   "scientificName" %in% colnames(occurCore)){
  missing_val_indCount <- occurCore$individualCount %in% c(NA, "")
  missing_val_occStat <- occurCore$occurrenceStatus %in% c(NA, "")
  missing_val_sciName <- occurCore$scientificName %in% c(NA, "")
  
  zero_indCount <- as.numeric(occurCore$individualCount) == 0
  abs_occStat <- occurCore$occurrenceStatus == "absent"

  bad_indCount <- which(!zero_indCount & missing_val_sciName & abs_occStat)
  
  # zero indCount with present occStat 
  condition <- which(zero_indCount & !abs_occStat)
  if(length(condition)>0){
    for(cd in 1:length(condition)){
      QC_report <- rbind(QC_report, 
                        data.frame(section="QC_miscellaneous",
                                   level="error",
                                   field="occurrenceStatus",
                                   row=condition[cd],
                                   value=NA,
                                   message="zero individualCount with occurrenceStatus present"))
    }
  }
  # non-zero indCount with absence or no sciName
  condition <- which(!zero_indCount & (missing_val_sciName | abs_occStat))
    if(length(condition)>0){
      for(cd in 1:length(condition)){
        QC_report <- rbind(QC_report, 
                        data.frame(section="QC_miscellaneous",
                                   level="error",
                                   field="occurrenceStatus",
                                   row=condition[cd],
                                   value=NA,
                                   message="individualCount > 0 with occurrenceStatus absent"))
    }
  }
}

#ToDo
#ULRS and DOIs in fields correctly formatted?

  
# 6.9 return output
if(nrow(QC_report[QC_report$section=="QC_miscellaneous",])>0){
  knitr::kable(QC_report[QC_report$section=="QC_miscellaneous",colnames(QC_report) %in% c("field","row", "value", "message")])
} else{message("-- no issues found --")}

```


## Part 7. QC on typos and pseudorepliactes
Pseudorepliacates are variants of strings that have an identical meaning but differ in notation. Here, strings in different fields are matched and flagged as potential pseudoreplicates if they have at leas 1, at most 2 characters difference (e.g capitals, typos,...) and do not differ more than 25% (to prevent matches between short words with some characters in common). In case a string is made up of multiple words separacted by spaces, matches are also found if the words have a different order (allowing 1-2 characters and 25% difference between words).

```{r QC_pseudoreplicates, echo = FALSE, results='asis'}
# 7.1 pseudo replicate variants 
# pseudo replicate variants are here defined as strings that have at most 2 character difference,
# but also differ no more than 25%, and/or are switched in order if there are multiple words in the string
typoFields <- c("scientificName", "verncularName", "identificationQualifier", "typeStatus", "identifiedBy",
                "associatedTaxa", "organismScope", "genus", "subgenus", "specificEpithet", "infraspecificEpithet",
                "samplingProtocol", "informationWithheld", "dataGeneralizations", "dynamicProperties",
                "recordedBy", "lifeStage", "reproductiveCondition", "behavior", "establishmentMeans",
                "degreeOfEstablishment", "pathway", "preparations", "disposition", "previousIdentifications",
                "organismRemarks", "habitat", "samplingEffort", 
                "location", "continent", "waterBody", "islandGroup", "island", "country", "stateProvince", "county",
                "municipality", "locality", "locationAccordingTo", 
                "georeferencedBy", "georeferenceProtocol", "georeferenceSources", "georeferenceVerificationStatus", 
                "formation", "member", "bed")
noHits <- TRUE
for(field in typoFields){
  if(field %in% colnames(occurCore)){
    uniques <- names(table(occurCore[,field]))
    uniques <- uniques[!uniques %in% c(NA, "")]
    freq <- data.frame(table(occurCore[,field]))
    freq <- freq[freq$Var1 %in% uniques,]

    QC_pseudorep <- data.frame(value_1=character(), value_2=character(), 
                            frequency_1=character(), frequency_2=character())
    for(targetString in uniques){
      if(!targetString %in% c(QC_pseudorep$value_1, QC_pseudorep$value_2)){
        matchLibrary <-uniques[nchar(uniques) %in% (nchar(targetString)-2:nchar(targetString)+2)]
        targetString_split <- str_split(targetString, " ")[[1]]
        for(matchString in matchLibrary){
          matchString_split <- str_split(matchString, " ")[[1]]
          matches_c <-c()
          for(targetSubString in targetString_split){
            matches_c <- c(matches_c, 
                           any(agrepl(targetSubString, matchString_split, 2) & #max 2 character different
                                 agrepl(targetSubString, matchString_split, 0.25))) #max 25% different
          }
          if(all(matches_c) & 
            targetString != matchString & 
            2*length(matches_c)==(length(targetString_split)+length(matchString_split))){
            QC_pseudorep <- rbind(QC_pseudorep, data.frame(value_1=targetString, 
                                                    value_2=matchString, 
                                                    frequency_1=freq[freq$Var1 == targetString,]$Freq,
                                                    frequency_2=freq[freq$Var1 == matchString,]$Freq))
            noHits <- FALSE
          }
        }
      }
    }
    # return output
    if(nrow(QC_pseudorep)>0){
      message(paste("Warning: in ", field, 
                    " some values were suspiciously alike, and may be pseudoreplicates:\n", sep=""))
      print(knitr::kable(QC_pseudorep))
      cat('\n')
      #print(QC_pseudorep)
    }
  }
}


if(noHits){
  message("-- no issues found --")
}

```

``` {r QC_finalize, echo = FALSE}
if(any("fatal_error" %in% QC_report$level)){
  QC_final <- "The dataset has **NOT passed** the QC\nReason:\n"
  fatal <- TRUE
}else{
  QC_final <- "Dataset has **PASSED** the QC!"
  fatal <- FALSE
}

```

# Conclusion: `r QC_final`

`r if(fatal){knitr::kable(QC_report[QC_report$level=="fatal_error",colnames(QC_report) %in% c("field","row", "value", "message")]) }`

